import { Component } from "@angular/core";
import { QuestionAngular } from "../question";
import { AngularComponentFactory } from "../component-factory";
import * as i0 from "@angular/core";
import * as i1 from "../components/character-counter/character-counter.component";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
export class TextQuestionComponent extends QuestionAngular {
    get value() {
        var _a;
        return (_a = this.model.value) !== null && _a !== void 0 ? _a : "";
    }
}
TextQuestionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextQuestionComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
TextQuestionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.17", type: TextQuestionComponent, selector: "sv-ng-text-question", usesInheritance: true, ngImport: i0, template: "  <ng-container [ngTemplateOutlet]=\"input\" *ngIf=\"!model.dataListId && !model.isReadOnlyRenderDiv()\"></ng-container>\n  <div *ngIf=\"model.dataListId && !model.isReadOnlyRenderDiv()\">\n    <ng-container [ngTemplateOutlet]=\"input\"></ng-container>\n    <datalist [id]=\"model.dataListId\">\n      <option *ngFor=\"let dataListItem of model.dataList\" [value]=\"dataListItem\"></option>\n    </datalist>\n  </div>\n  <div *ngIf=\"model.isReadOnlyRenderDiv()\" #contentElement>{{ model.value }}</div>\n  <ng-template #input>\n    <input [style]=\"model.inputStyle\" [class]=\"model.getControlClass()\" [attr.list]=\"model.dataListId\"\n    (change)=\"model.onChange($event)\" [value]=\"value\" [disabled]=\"model.isInputReadOnly\" [type]=\"model.inputType\" [id]=\"model.inputId\" [attr.placeholder]=\"model.renderedPlaceholder || ''\"\n    (keyup)=\"model.onKeyUp($event)\" (keydown)=\"model.onKeyDown($event)\" (blur)=\"model.onBlur($event)\" (focus)=\"model.onFocus($event)\" (compositionupdate)=\"model.onCompositionUpdate($event)\" \n    [attr.size] = \"model.renderedInputSize\" [attr.maxlength]= \"model.getMaxLength()\" [attr.min]=\"model.renderedMin\"\n    [attr.max]=\"model.renderedMax\" [attr.step]=\"model.renderedStep\" [attr.max]=\"model.renderedMax\" [attr.aria-required]=\"model.a11y_input_ariaRequired\"\n    [attr.aria-label]=\"model.a11y_input_ariaLabel\" [attr.aria-labelledby]=\"model.a11y_input_ariaLabelledBy\" [attr.aria-invalid]=\"model.a11y_input_ariaInvalid\" [attr.aria-describedby]=\"model.a11y_input_ariaDescribedBy\" [attr.autocomplete]=\"model.autocomplete\" #contentElement/>\n    <sv-ng-character-counter *ngIf=\"model.getMaxLength()\" \n    [counter]=\"model.characterCounter\"\n    [remainingCharacterCounter]=\"model.cssClasses.remainingCharacterCounter\">\n  </sv-ng-character-counter>\n  </ng-template>", styles: [""], components: [{ type: i1.CharacterCounterComponent, selector: "sv-ng-character-counter", inputs: ["counter", "remainingCharacterCounter"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i3.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: TextQuestionComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "sv-ng-text-question",
                    templateUrl: "./text.component.html",
                    styleUrls: ["./text.component.scss"]
                }]
        }] });
AngularComponentFactory.Instance.registerComponent("text-question", TextQuestionComponent);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcXVlc3Rpb25zL3RleHQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vc3JjL3F1ZXN0aW9ucy90ZXh0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU5QyxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7QUFPL0QsTUFBTSxPQUFPLHFCQUFzQixTQUFRLGVBQWtDO0lBQzNFLElBQUksS0FBSzs7UUFDUCxPQUFPLE1BQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLG1DQUFJLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzttSEFIVSxxQkFBcUI7dUdBQXJCLHFCQUFxQixrRkNWbEMsdXpEQW1CZ0I7NEZEVEgscUJBQXFCO2tCQUxqQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxxQkFBcUI7b0JBQy9CLFdBQVcsRUFBRSx1QkFBdUI7b0JBQ3BDLFNBQVMsRUFBRSxDQUFDLHVCQUF1QixDQUFDO2lCQUNyQzs7QUFPRCx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsZUFBZSxFQUFFLHFCQUFxQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgUXVlc3Rpb25Bbmd1bGFyIH0gZnJvbSBcIi4uL3F1ZXN0aW9uXCI7XG5pbXBvcnQgeyBRdWVzdGlvblRleHRNb2RlbCB9IGZyb20gXCJzdXJ2ZXktY29yZVwiO1xuaW1wb3J0IHsgQW5ndWxhckNvbXBvbmVudEZhY3RvcnkgfSBmcm9tIFwiLi4vY29tcG9uZW50LWZhY3RvcnlcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInN2LW5nLXRleHQtcXVlc3Rpb25cIixcbiAgdGVtcGxhdGVVcmw6IFwiLi90ZXh0LmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi90ZXh0LmNvbXBvbmVudC5zY3NzXCJdXG59KVxuZXhwb3J0IGNsYXNzIFRleHRRdWVzdGlvbkNvbXBvbmVudCBleHRlbmRzIFF1ZXN0aW9uQW5ndWxhcjxRdWVzdGlvblRleHRNb2RlbD4ge1xuICBnZXQgdmFsdWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC52YWx1ZSA/PyBcIlwiO1xuICB9XG59XG5cbkFuZ3VsYXJDb21wb25lbnRGYWN0b3J5Lkluc3RhbmNlLnJlZ2lzdGVyQ29tcG9uZW50KFwidGV4dC1xdWVzdGlvblwiLCBUZXh0UXVlc3Rpb25Db21wb25lbnQpOyIsIiAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnB1dFwiICpuZ0lmPVwiIW1vZGVsLmRhdGFMaXN0SWQgJiYgIW1vZGVsLmlzUmVhZE9ubHlSZW5kZXJEaXYoKVwiPjwvbmctY29udGFpbmVyPlxuICA8ZGl2ICpuZ0lmPVwibW9kZWwuZGF0YUxpc3RJZCAmJiAhbW9kZWwuaXNSZWFkT25seVJlbmRlckRpdigpXCI+XG4gICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnB1dFwiPjwvbmctY29udGFpbmVyPlxuICAgIDxkYXRhbGlzdCBbaWRdPVwibW9kZWwuZGF0YUxpc3RJZFwiPlxuICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgZGF0YUxpc3RJdGVtIG9mIG1vZGVsLmRhdGFMaXN0XCIgW3ZhbHVlXT1cImRhdGFMaXN0SXRlbVwiPjwvb3B0aW9uPlxuICAgIDwvZGF0YWxpc3Q+XG4gIDwvZGl2PlxuICA8ZGl2ICpuZ0lmPVwibW9kZWwuaXNSZWFkT25seVJlbmRlckRpdigpXCIgI2NvbnRlbnRFbGVtZW50Pnt7IG1vZGVsLnZhbHVlIH19PC9kaXY+XG4gIDxuZy10ZW1wbGF0ZSAjaW5wdXQ+XG4gICAgPGlucHV0IFtzdHlsZV09XCJtb2RlbC5pbnB1dFN0eWxlXCIgW2NsYXNzXT1cIm1vZGVsLmdldENvbnRyb2xDbGFzcygpXCIgW2F0dHIubGlzdF09XCJtb2RlbC5kYXRhTGlzdElkXCJcbiAgICAoY2hhbmdlKT1cIm1vZGVsLm9uQ2hhbmdlKCRldmVudClcIiBbdmFsdWVdPVwidmFsdWVcIiBbZGlzYWJsZWRdPVwibW9kZWwuaXNJbnB1dFJlYWRPbmx5XCIgW3R5cGVdPVwibW9kZWwuaW5wdXRUeXBlXCIgW2lkXT1cIm1vZGVsLmlucHV0SWRcIiBbYXR0ci5wbGFjZWhvbGRlcl09XCJtb2RlbC5yZW5kZXJlZFBsYWNlaG9sZGVyIHx8ICcnXCJcbiAgICAoa2V5dXApPVwibW9kZWwub25LZXlVcCgkZXZlbnQpXCIgKGtleWRvd24pPVwibW9kZWwub25LZXlEb3duKCRldmVudClcIiAoYmx1cik9XCJtb2RlbC5vbkJsdXIoJGV2ZW50KVwiIChmb2N1cyk9XCJtb2RlbC5vbkZvY3VzKCRldmVudClcIiAoY29tcG9zaXRpb251cGRhdGUpPVwibW9kZWwub25Db21wb3NpdGlvblVwZGF0ZSgkZXZlbnQpXCIgXG4gICAgW2F0dHIuc2l6ZV0gPSBcIm1vZGVsLnJlbmRlcmVkSW5wdXRTaXplXCIgW2F0dHIubWF4bGVuZ3RoXT0gXCJtb2RlbC5nZXRNYXhMZW5ndGgoKVwiIFthdHRyLm1pbl09XCJtb2RlbC5yZW5kZXJlZE1pblwiXG4gICAgW2F0dHIubWF4XT1cIm1vZGVsLnJlbmRlcmVkTWF4XCIgW2F0dHIuc3RlcF09XCJtb2RlbC5yZW5kZXJlZFN0ZXBcIiBbYXR0ci5tYXhdPVwibW9kZWwucmVuZGVyZWRNYXhcIiBbYXR0ci5hcmlhLXJlcXVpcmVkXT1cIm1vZGVsLmExMXlfaW5wdXRfYXJpYVJlcXVpcmVkXCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm1vZGVsLmExMXlfaW5wdXRfYXJpYUxhYmVsXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cIm1vZGVsLmExMXlfaW5wdXRfYXJpYUxhYmVsbGVkQnlcIiBbYXR0ci5hcmlhLWludmFsaWRdPVwibW9kZWwuYTExeV9pbnB1dF9hcmlhSW52YWxpZFwiIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwibW9kZWwuYTExeV9pbnB1dF9hcmlhRGVzY3JpYmVkQnlcIiBbYXR0ci5hdXRvY29tcGxldGVdPVwibW9kZWwuYXV0b2NvbXBsZXRlXCIgI2NvbnRlbnRFbGVtZW50Lz5cbiAgICA8c3YtbmctY2hhcmFjdGVyLWNvdW50ZXIgKm5nSWY9XCJtb2RlbC5nZXRNYXhMZW5ndGgoKVwiIFxuICAgIFtjb3VudGVyXT1cIm1vZGVsLmNoYXJhY3RlckNvdW50ZXJcIlxuICAgIFtyZW1haW5pbmdDaGFyYWN0ZXJDb3VudGVyXT1cIm1vZGVsLmNzc0NsYXNzZXMucmVtYWluaW5nQ2hhcmFjdGVyQ291bnRlclwiPlxuICA8L3N2LW5nLWNoYXJhY3Rlci1jb3VudGVyPlxuICA8L25nLXRlbXBsYXRlPiJdfQ==